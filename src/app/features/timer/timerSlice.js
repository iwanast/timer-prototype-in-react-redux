import { createSlice } from "@reduxjs/toolkit";

// episode can be "Waiting", "Break" or "Focus"
const initialState = {
  durationTimer: 20,
  durationBreak: 3,
  value: 5,
  status: "idle",
  episode: "Waiting",
  pause: false,
}

export const timerSlice = createSlice({
  name: "timer",
  initialState,
  reducers: {
    // because of Redux toolkit which uses the Immer library can I write mutable logic but Immer will make the changes immutable
    decrement: (state) => {
        state.value -= 1;
    },
    start: (state) => {
      state.pause = "false"
      state.status = "active"
    },
    pause: (state) => {
      state.pause = "true"
      state.status = "idle"
    },
    focusTime: (state) => {
      state.episode = "Focus"
    },
   
    // We will see what the best design will be for showing a break... 
    timeForBreak : (state) => {
      state.value = state.durationBreak
      state.episode = "Break"
    },
    reset: (state) => {
      state.value = state.durationTimer;
      state.episode = "Waiting"
      state.status = "idle"
    },
    setDurationTimer: (state, action) => {
      state.durationTimer = action.payload.durationTimer 
      state.value = action.payload.durationTimer 
    },
    setDurationBreak: (state, action) => {
      state.durationBreak = action.payload.durationBreak
    }
  },
  /*
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
       .addCase(incrementAsync.pending, (state) => { 
          state.status = "loading";
        })
       .addCase(incrementAsync.fulfilled, (state) => {
        state.status = "idle"; 
        state.value += action.payload;
        })
  },
*/
});

export const { decrement, pause, start, reset, focusTime, timeForBreak, setDurationBreak, setDurationTimer } = timerSlice.actions; 

/*
THUNK function: (typically used for async requests)
export const incrementAsync = createAsyncThunk(
  "counter/fetchCount",
  async (amount) => {
    const response = await fetchCount(amount);
    return response.data;
  }
);
*/

// This selector allows to use a value of the state in a Hook in React. Can also be defined inline but I did it now here
export const selectTime = (state) => state.timer.value
export const selectStatusTimer = (state) => state.timer.status
export const selectStatusPause = (state) => state.timer.pause
export const selectDurationTimer = (state) => state.timer.durationTimer
export const selectDurationBreak = (state) => state.timer.durationBreak
export const selectEpisode = (state) => state.timer.episode

// THUNKS written by hand, here conditionally dispatching
export const startTimer = () => (dispatch, getState) => {
  dispatch(start())
  const initialEpisode = selectEpisode(getState());
  if (initialEpisode === "Waiting") dispatch(focusTime())
  const startedTimer = setInterval(decrementIfStillTimeLeftAndNotPause, 1000);

  function decrementIfStillTimeLeftAndNotPause() {         
    const currentValue = selectTime(getState());
    const currentState = selectStatusTimer(getState());
    const currentEpisode = selectEpisode(getState());
    if(currentState === "active") {
      if (currentValue >= 1){
        dispatch(decrement());
      }else if(currentEpisode === "Break") {
        clearInterval(startedTimer);
        dispatch(reset());
      }else if(currentEpisode === "Focus"){
        dispatch(timeForBreak());
      }      
    }else if(currentState === "idle"){
      clearInterval(startedTimer)
    } else{
      console.log("Case not defined")
    }
  };
}

export default timerSlice.reducer;