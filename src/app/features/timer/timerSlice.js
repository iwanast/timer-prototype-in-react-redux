import { createSlice } from "@reduxjs/toolkit";
import { selectDurationBreak, selectDurationTimer } from "../settings/settingsSlice";

// episode can be "Waiting", "Break" or "Focus"
const initialState = {
  value: 0,
  status: "idle",
  episode: "Waiting",
  pause: false,
}

export const timerSlice = createSlice({
  name: "timer",
  initialState,
  reducers: {
    // because of Redux toolkit which uses the Immer library can I write mutable logic but Immer will make the changes immutable
    decrement: (state) => {
        state.value -= 1;
    },
    start: (state) => {
      state.pause = "false"
      state.status = "active"
    },
    pause: (state) => {
      state.pause = "true"
      state.status = "idle"
    },
    setEpisode: (state, action) => {
      if(action.payload.episode === "Waiting" || action.payload.episode === "Break" || action.payload.episode === "Focus")
      state.episode = action.payload.episode
    },
    changeValue: (state, action) => {
      state.value = action.payload.value
    },
    reset: () => {
      return initialState;
    },
  },
  /*
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
       .addCase(incrementAsync.pending, (state) => { 
          state.status = "loading";
        })
       .addCase(incrementAsync.fulfilled, (state) => {
        state.status = "idle"; 
        state.value += action.payload;
        })
  },
*/
});

export const { decrement, pause, start, reset, setEpisode, changeValue } = timerSlice.actions; 

/*
THUNK function: (typically used for async requests)
export const incrementAsync = createAsyncThunk(
  "counter/fetchCount",
  async (amount) => {
    const response = await fetchCount(amount);
    return response.data;
  }
);
*/

// This selector allows to use a value of the state in a Hook in React. Can also be defined inline but I did it now here
export const selectTimerValue = (state) => state.timer.value
export const selectStatusTimer = (state) => state.timer.status
export const selectStatusPause = (state) => state.timer.pause
// export const selectDurationTimer = (state) => state.timer.durationTimer
// export const selectDurationBreak = (state) => state.timer.durationBreak
export const selectEpisode = (state) => state.timer.episode

// THUNKS written by hand, here conditionally dispatching
export const startTimer = () => (dispatch, getState) => {
  dispatch(start())
  const durationTimer = selectDurationTimer(getState())
  const initialEpisode = selectEpisode(getState());
  if (initialEpisode === "Waiting"){
    dispatch(setEpisode({episode: "Focus"}))
    dispatch(changeValue({value: durationTimer}))
  } 
  const startedTimer = setInterval(decrementIfStillTimeLeftAndNotPause, 1000);

  function decrementIfStillTimeLeftAndNotPause() {         
    const currentValue = selectTimerValue(getState());
    const currentState = selectStatusTimer(getState());
    const currentEpisode = selectEpisode(getState());
    const durationBreak = selectDurationBreak(getState())
    if(currentState === "active") {
      if (currentValue >= 1){
        dispatch(decrement());
      }else if(currentEpisode === "Break") {
        clearInterval(startedTimer);
        dispatch(reset());
        dispatch(changeValue({value: durationTimer}))
      }else if(currentEpisode === "Focus"){
        dispatch(setEpisode({episode: "Break"}));
        dispatch(changeValue({value: durationBreak}))
      }      
    }else if(currentState === "idle"){
      clearInterval(startedTimer)
    } else{
      console.log("Case not defined")
    }
  };
}

export default timerSlice.reducer;